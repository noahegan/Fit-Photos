<script>
(async function(){
  const fileInputs = {
    front: document.getElementById('front'),
    side:  document.getElementById('side'),
    back:  document.getElementById('back')
  };
  const buildBtn = document.getElementById('build');
  const dlBtn = document.getElementById('download');
  const out = document.getElementById('output');
  const ctx = out.getContext('2d');

  // Board layout constants
  const PAD = 28, GAP = 16, COLS = 3;
  const TOP_BANNER = 80;
  const cellW = Math.floor((out.width - PAD*2 - GAP*(COLS-1)) / COLS);
  const cellH = out.height - PAD*2 - TOP_BANNER;

  // ---- Load BodyPix once
  const net = await bodyPix.load({
    architecture: 'MobileNetV1',
    outputStride: 16,
    multiplier: 0.75,
    quantBytes: 2
  });

  function loadImage(file){
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
      img.onerror = reject;
      img.src = url;
    });
  }

  // Build a filled, face-removed mask from part segmentation
  function buildMaskFromParts(partSeg, w, h) {
    // Parts we want to keep (include arms, torso, legs, hands, feet)
    // We exclude face/head parts so no faces show.
    const KEEP = new Set([
      'leftUpperArm','rightUpperArm','leftLowerArm','rightLowerArm',
      'leftHand','rightHand',
      'torso',
      'leftUpperLeg','rightUpperLeg','leftLowerLeg','rightLowerLeg',
      'leftFoot','rightFoot'
    ]);

    // Map each pixel to keep/discard
    const keepBool = new Uint8Array(w*h);
    for (let i=0; i<partSeg.data.length; i++) {
      const p = partSeg.allPoses[0].partIds[ partSeg.data[i] ] || null;
      const partName = partSeg.partNames[ partSeg.data[i] ] || null;
      if (partName && KEEP.has(partName)) keepBool[i] = 1;
    }

    // Convert to RGBA alpha mask (filled)
    const rgba = new Uint8ClampedArray(w*h*4);
    for (let i=0, j=0; i<w*h; i++, j+=4) {
      const a = keepBool[i] ? 255 : 0;
      rgba[j] = 255; rgba[j+1] = 255; rgba[j+2] = 255; rgba[j+3] = a;
    }
    return rgba;
  }

  // Simple blur + threshold on the alpha channel to close small holes / keep arms
  function refineAlpha(rgba, w, h) {
    // Extract alpha
    const alpha = new Uint8ClampedArray(w*h);
    for (let i=0, j=0; i<w*h; i++, j+=4) alpha[i] = rgba[j+3];

    // Box blur (radius 2)
    const r = 2;
    const tmp = new Uint16Array(w*h);
    // horizontal
    for (let y=0; y<h; y++){
      let sum=0;
      for (let x=0; x<w; x++){
        const add = alpha[y*w + Math.min(w-1, x+r)];
        const sub = alpha[y*w + Math.max(0, x-r-1)];
        sum += add - sub;
        tmp[y*w + x] = sum;
      }
    }
    // vertical
    const outA = new Uint8ClampedArray(w*h);
    const span = (2*r+1)*(2*r+1);
    for (let x=0; x<w; x++){
      let sum=0;
      for (let y=0; y<h; y++){
        const add = tmp[Math.min(h-1, y+r)*w + x];
        const sub = tmp[Math.max(0, y-r-1)*w + x];
        sum += add - sub;
        outA[y*w + x] = Math.round(sum / span);
      }
    }

    // Threshold to solid mask
    const THRESH = 40; // lower -> keep more; higher -> tighter
    for (let i=0, j=0; i<w*h; i++, j+=4){
      const a = outA[i] > THRESH ? 255 : 0;
      rgba[j] = 255; rgba[j+1] = 255; rgba[j+2] = 255; rgba[j+3] = a;
    }
    return rgba;
  }

  function bboxFromAlpha(rgba, w, h) {
    let top=h, left=w, right=0, bottom=0, found=false;
    for (let y=0, i=0; y<h; y++){
      for (let x=0; x<w; x++, i+=4){
        if (rgba[i+3] > 0){
          found=true;
          if (x<left) left=x;
          if (x>right) right=x;
          if (y<top) top=y;
          if (y>bottom) bottom=y;
        }
      }
    }
    if (!found) return null;
    return { x:left, y:top, w:(right-left+1), h:(bottom-top+1), bottom };
  }

  async function segmentAndCrop(img){
    // Downscale for speed
    const maxSide = 1000;
    const scale = Math.min(1, maxSide / Math.max(img.width, img.height));
    const w = Math.round(img.width * scale);
    const h = Math.round(img.height * scale);

    const temp = document.createElement('canvas');
    temp.width = w; temp.height = h;
    const tctx = temp.getContext('2d');
    tctx.drawImage(img, 0, 0, w, h);

    // ---- Part segmentation (keeps arms; lets us drop the face)
    const parts = await net.segmentPersonParts(temp, {
      internalResolution: 'high',
      segmentationThreshold: 0.6
    });

    // Build + refine mask
    let maskRGBA = buildMaskFromParts(parts, w, h);
    maskRGBA = refineAlpha(maskRGBA, w, h);

    // Bounding box of subject (after refinement)
    const box0 = bboxFromAlpha(maskRGBA, w, h);

    // If no mask found, fallback to a centered square crop
    const fallback = !box0
      ? { x: Math.max(0, (w - Math.min(w,h))/2), y: Math.max(0, (h - Math.min(w,h))/2),
          w: Math.min(w,h), h: Math.min(w,h), bottom: Math.min(w,h) }
      : box0;

    // Consistent crop rules:
    //  - Remove head: raise top to roughly shoulder level by trimming 10% of height from top
    //  - Keep arms: expand width margin
    //  - Ensure constant bottom padding relative to outfit: add 40px below lowest pixel (clamped)
    const MARGIN_X = 24;
    const HEAD_TRIM = Math.round(fallback.h * 0.10);
    const BOTTOM_PAD = 40;

    let cx = Math.max(0, fallback.x - MARGIN_X);
    let cy = Math.max(0, fallback.y + HEAD_TRIM);
    let cw = Math.min(w - cx, fallback.w + MARGIN_X*2);
    // bottom is the lowest alpha pixel row; extend by padding
    let desiredBottom = Math.min(h-1, fallback.bottom + BOTTOM_PAD);
    let ch = Math.min(h - cy, desiredBottom - cy);

    // Prepare canvases
    const personC = document.createElement('canvas');
    personC.width = cw; personC.height = ch;
    const pctx = personC.getContext('2d');

    // Create a canvas for the refined mask
    const maskCanvas = document.createElement('canvas');
    maskCanvas.width = w; maskCanvas.height = h;
    const mctx = maskCanvas.getContext('2d');
    const mimg = new ImageData(maskRGBA, w, h);
    mctx.putImageData(mimg, 0, 0);

    // Composite: white background, then clip to mask area
    pctx.save();
    pctx.fillStyle = '#fff';
    pctx.fillRect(0,0,cw,ch);
    pctx.drawImage(maskCanvas, cx, cy, cw, ch, 0, 0, cw, ch);
    pctx.globalCompositeOperation = 'source-in';
    pctx.drawImage(temp, cx, cy, cw, ch, 0, 0, cw, ch);
    pctx.restore();

    // Return crop + the subject crop height (used for normalization)
    return { canvas: personC, subjectHeight: ch };
  }

  function placeLabeled(context, x, y, w, h, label){
    context.save();
    context.fillStyle = '#fff';
    context.fillRect(x, y, w, h + TOP_BANNER);
    context.fillStyle = '#111';
    context.font = 'bold 40px Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(label, x + w/2, y + 24);
    context.restore();
  }

  async function build(){
    const files = [fileInputs.front.files[0], fileInputs.side.files[0], fileInputs.back.files[0]];
    if (!files.every(Boolean)) { alert('Please select all three photos (Front, Side, Back).'); return; }

    // Clear board
    ctx.clearRect(0,0,out.width,out.height);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,out.width,out.height);

    const labels = ['FRONT', 'SIDE', 'BACK'];

    // Load & segment all three first (so we can normalize scale)
    const loaded = await Promise.all(files.map(loadImage));
    const crops = await Promise.all(loaded.map(segmentAndCrop));

    // Normalize zoom: make all three use the same subject height
    const usableH = cellH - 40;      // area below labels
    const targetH = usableH - 24;    // padding
    const heights = crops.map(c => c.subjectHeight).sort((a,b)=>a-b);
    const commonHeight = heights[1]; // median of 3

    for (let i=0; i<3; i++){
      const { canvas: cut, subjectHeight } = crops[i];

      // Column area + label
      const x = PAD + i * (cellW + GAP);
      const y = PAD;
      placeLabeled(ctx, x, y, cellW, cellH, labels[i]);

      // Scale so subject heights match across columns
      const scale = targetH / commonHeight;
      let drawW = Math.round(cut.width * scale);
      let drawH = Math.round(cut.height * scale);

      // Respect max width
      const maxW = cellW - 24;
      if (drawW > maxW) {
        const s = maxW / drawW;
        drawW = Math.round(drawW * s);
        drawH = Math.round(drawH * s);
      }

      const dx = x + (cellW - drawW)/2;
      const dy = y + 40 + (usableH - drawH)/2;

      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.12)';
      ctx.shadowBlur = 12; ctx.shadowOffsetY = 6;
      ctx.drawImage(cut, dx, dy, drawW, drawH);
      ctx.restore();
    }
  }

  buildBtn.addEventListener('click', () => build());
  dlBtn.addEventListener('click', () => {
    const url = out.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'fit-board-front-side-back.png';
    a.click();
  });
})();
</script>
