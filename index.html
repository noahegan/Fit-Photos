<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Free 3‑Photo Fit Board Version 1</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
           margin: 24px; background:#f6f7fb; color:#111; }
    h1 { margin: 0 0 8px; }
    .app { max-width: 980px; margin: 0 auto; background:#fff; border-radius: 16px;
           box-shadow: 0 6px 24px rgba(0,0,0,.08); padding: 20px; }
    .grid { display:grid; grid-template-columns: 1fr; gap:16px; }
    @media (min-width:780px){ .grid{ grid-template-columns: repeat(3, 1fr);} }
    .card { background:#fafbff; border:1px solid #e7e9f3; border-radius:12px; padding:14px; }
    label { font-weight: 600; font-size: 14px; display:block; margin-bottom:8px; }
    input[type="file"] { width:100%; padding:10px; border:1px dashed #cdd2e2; border-radius:10px; background:#fff; }
    button { cursor:pointer; border:0; background:#111; color:#fff; padding:12px 16px; border-radius:12px; font-weight:700; }
    button.secondary { background:#fff; color:#111; border:1px solid #d0d5e7; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    canvas { width:100%; max-width:100%; background:#fff; border-radius:12px; border:1px solid #e7e9f3; }
    small.mono { font-family: ui-monospace, Menlo, Consolas, monospace; color:#6b7280; }
    .error { background:#fff3f3; color:#7a0000; border:1px solid #f0b8b8; padding:10px 12px; border-radius:10px; display:none; margin-bottom:12px; }
  </style>
  <!-- Fully client‑side -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0"></script>
</head>
<body>
  <div class="app">
    <h1>Free 3‑Photo Fit Board</h1>
    <div id="err" class="error"></div>
    <p>Upload <b>Front</b>, <b>Side</b>, and <b>Back</b> photos. The tool takes a <b>rectangular crop</b> with consistent framing across columns (same zoom, same top/bottom lines), keeps arms, trims just a bit above the neck (equal for all), and adds fixed bottom padding.</p>

    <div class="grid">
      <div class="card"><label>Front</label><input id="front" type="file" accept="image/*" /></div>
      <div class="card"><label>Side</label><input id="side" type="file" accept="image/*" /></div>
      <div class="card"><label>Back</label><input id="back" type="file" accept="image/*" /></div>
    </div>

    <div style="height:12px"></div>
    <div class="row">
      <button id="build">Build Layout</button>
      <button id="download" class="secondary">Download PNG</button>
      <small class="mono">Everything runs on‑device. No uploads.</small>
    </div>

    <div style="height:12px"></div>
    <canvas id="output" width="1500" height="850" aria-label="Final layout canvas"></canvas>
  </div>

<script>
(async function(){
  const input = {
    front: document.getElementById('front'),
    side:  document.getElementById('side'),
    back:  document.getElementById('back')
  };
  const buildBtn = document.getElementById('build');
  const dlBtn = document.getElementById('download');
  const out = document.getElementById('output');
  const ctx = out.getContext('2d');
  const errBox = document.getElementById('err');

  function showErr(msg){ errBox.textContent = msg; errBox.style.display = 'block'; }
  function clearErr(){ errBox.textContent = ''; errBox.style.display = 'none'; }

  // Layout
  const PAD = 28, GAP = 16, COLS = 3, TOP_BANNER = 80;
  const cellW = Math.floor((out.width - PAD*2 - GAP*(COLS-1)) / COLS);
  const cellH = out.height - PAD*2 - TOP_BANNER;

  // Framing constants (applied equally to all views)
  const SIDE_PAD_PCT  = 0.14; // widen the bbox to keep arms (each side = 14% of bbox width)
  const HEAD_TRIM_PCT = 0.03; // light trim above bbox top to avoid chin/face (more neck shown)
  const BOTTOM_PAD_PX = 60;   // fixed extra space below the lowest foreground pixel

  // Load BodyPix
  let net;
  try {
    net = await bodyPix.load({
      architecture: 'MobileNetV1',
      outputStride: 16,
      multiplier: 0.75,
      quantBytes: 2
    });
  } catch (e) {
    showErr('Failed to load BodyPix. Check your connection and refresh.');
    console.error(e); return;
  }

  function loadImage(file){
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
      img.onerror = reject;
      img.src = url;
    });
  }

  function bboxFromMaskAlpha(rgba, w, h){
    let top=h, left=w, right=0, bottom=0, found=false;
    for (let y=0, i=0; y<h; y++){
      for (let x=0; x<w; x++, i+=4){
        if (rgba[i+3] > 0){
          found = true;
          if (x<left) left=x;
          if (x>right) right=x;
          if (y<top) top=y;
          if (y>bottom) bottom=y;
        }
      }
    }
    if (!found) return null;
    return { x:left, y:top, w:(right-left+1), h:(bottom-top+1), bottom };
  }

  // Measure a smart rectangular crop from person segmentation
  async function measureRect(img){
    const maxSide = 1200;
    const scale = Math.min(1, maxSide / Math.max(img.width, img.height));
    const w = Math.round(img.width * scale);
    const h = Math.round(img.height * scale);

    const temp = document.createElement('canvas');
    temp.width = w; temp.height = h;
    const tctx = temp.getContext('2d');
    tctx.drawImage(img, 0, 0, w, h);

    const seg = await net.segmentPerson(temp, {
      internalResolution: 'high',
      segmentationThreshold: 0.6
    });
    const mask = bodyPix.toMask(seg, {r:255,g:255,b:255,a:255}, {r:0,g:0,b:0,a:0}, false);
    const box = bboxFromMaskAlpha(mask.data, mask.width, mask.height);

    // Fallback if no person detected
    if (!box){
      const s = Math.min(w,h);
      return { temp, rect: { x:(w-s)/2, y:(h-s)/2, w:s, h:s } };
    }

    // Horizontal padding for arms
    const sidePad = Math.round(box.w * SIDE_PAD_PCT);
    let x  = Math.max(0, box.x - sidePad);
    let rw = Math.min(w - x, box.w + sidePad*2);

    // Light trim above neck (equal for all)
    const headTrim = Math.round(box.h * HEAD_TRIM_PCT);
    let y  = Math.max(0, box.y + headTrim);

    // Fixed bottom padding
    const yBottomDesired = Math.min(h-1, box.bottom + BOTTOM_PAD_PX);
    let rh = Math.min(h - y, yBottomDesired - y);

    // Clamp
    if (x + rw > w) rw = w - x;
    if (y + rh > h) rh = h - y;

    return { temp, rect: { x, y, w: rw, h: rh } };
  }

  function placeLabel(context, x, y, w, h, label){
    context.save();
    context.fillStyle = '#fff';
    context.fillRect(x, y, w, h + TOP_BANNER);
    context.fillStyle = '#111';
    context.font = 'bold 40px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(label, x + w/2, y + 24);
    context.restore();
  }

  // NEW build(): force identical draw heights so tops & bottoms align exactly
  async function build(){
    clearErr();
    const files = [input.front.files[0], input.side.files[0], input.back.files[0]];
    if (!files.every(Boolean)) { showErr('Please select all three photos.'); return; }

    // Background
    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0,out.width,out.height);

    const labels = ['FRONT','SIDE','BACK'];

    let imgs, measures;
    try {
      imgs = await Promise.all(files.map(loadImage));
      measures = await Promise.all(imgs.map(measureRect));
    } catch (e) {
      showErr('Error analyzing one of the photos. Try again or refresh.');
      console.error(e); return;
    }

    const usableH = cellH - 40;  // under label
    const targetH = usableH - 24;
    const maxW    = cellW - 24;  // side padding

    // Compute, for each image, the tallest we can draw without exceeding width or target height
    const perImageMaxHeights = measures.map(({rect}) => {
      const heightByTarget = targetH;
      const heightByWidth  = rect.h * (maxW / rect.w); // if width limited, height must shrink
      return Math.min(heightByTarget, heightByWidth);
    });

    // Use the minimum of those so all three can share the same draw height
    const globalDrawH = Math.floor(Math.min(...perImageMaxHeights));

    for (let i=0; i<3; i++){
      const { temp, rect } = measures[i];

      const x = PAD + i * (cellW + GAP);
      const y = PAD;
      placeLabel(ctx, x, y, cellW, cellH, labels[i]);

      // Scale to identical height across columns
      const scale = globalDrawH / rect.h;
      const drawH = globalDrawH;
      const drawW = Math.round(rect.w * scale);

      const dx = x + (cellW - drawW)/2;
      const dy = y + 40 + (usableH - drawH)/2;

      ctx.drawImage(temp, rect.x, rect.y, rect.w, rect.h, dx, dy, drawW, drawH);
    }
  }

  buildBtn.addEventListener('click', build);

  dlBtn.addEventListener('click', () => {
    const url = out.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'fit-board-front-side-back.png';
    a.click();
  });
})();
</script>
</body>
</html>
