<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Free 3‑Photo Fit Board</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
           margin: 24px; background:#f6f7fb; color:#111; }
    h1 { margin: 0 0 8px; }
    .app { max-width: 980px; margin: 0 auto; background:#fff; border-radius: 16px;
           box-shadow: 0 6px 24px rgba(0,0,0,.08); padding: 20px; }
    .grid { display:grid; grid-template-columns: 1fr; gap:16px; }
    @media (min-width:780px){ .grid{ grid-template-columns: repeat(3, 1fr);} }
    .card { background:#fafbff; border:1px solid #e7e9f3; border-radius:12px; padding:14px; }
    label { font-weight: 600; font-size: 14px; display:block; margin-bottom:8px; }
    input[type="file"] { width:100%; padding:10px; border:1px dashed #cdd2e2; border-radius:10px; background:#fff; }
    button { cursor:pointer; border:0; background:#111; color:#fff; padding:12px 16px; border-radius:12px; font-weight:700; }
    button.secondary { background:#fff; color:#111; border:1px solid #d0d5e7; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    canvas { width:100%; max-width:100%; background:#fff; border-radius:12px; border:1px solid #e7e9f3; }
    small.mono { font-family: ui-monospace, Menlo, Consolas, monospace; color:#6b7280; }
    .error { background:#fff3f3; color:#7a0000; border:1px solid #f0b8b8; padding:10px 12px; border-radius:10px; display:none; margin-bottom:12px; }
  </style>
  <!-- Runs fully in the browser -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0"></script>
</head>
<body>
  <div class="app">
    <h1>Free 3‑Photo Fit Board</h1>
    <div id="err" class="error"></div>
    <p>Upload <b>Front</b>, <b>Side</b>, and <b>Back</b> photos. The tool takes a <b>rectangular crop</b> with consistent framing: includes arms, light head trim, fixed bottom padding, and the same zoom across columns.</p>

    <div class="grid">
      <div class="card"><label>Front</label><input id="front" type="file" accept="image/*" /></div>
      <div class="card"><label>Side</label><input id="side" type="file" accept="image/*" /></div>
      <div class="card"><label>Back</label><input id="back" type="file" accept="image/*" /></div>
    </div>

    <div style="height:12px"></div>
    <div class="row">
      <button id="build">Build Layout</button>
      <button id="download" class="secondary">Download PNG</button>
      <small class="mono">Everything runs on‑device. No uploads.</small>
    </div>

    <div style="height:12px"></div>
    <canvas id="output" width="1500" height="850" aria-label="Final layout canvas"></canvas>
  </div>

<script>
(async function(){
  const input = {
    front: document.getElementById('front'),
    side:  document.getElementById('side'),
    back:  document.getElementById('back')
  };
  const buildBtn = document.getElementById('build');
  const dlBtn = document.getElementById('download');
  const out = document.getElementById('output');
  const ctx = out.getContext('2d');
  const errBox = document.getElementById('err');

  function showErr(msg){
    errBox.textContent = msg;
    errBox.style.display = 'block';
  }
  function clearErr(){ errBox.style.display = 'none'; errBox.textContent=''; }

  // Layout constants
  const PAD = 28, GAP = 16, COLS = 3, TOP_BANNER = 80;
  const cellW = Math.floor((out.width - PAD*2 - GAP*(COLS-1)) / COLS);
  const cellH = out.height - PAD*2 - TOP_BANNER;

  // Framing rules (tweak here)
  const SIDE_PAD_PCT  = 0.14; // keep arms (each side = 14% of bbox width)
  const HEAD_TRIM_PCT = 0.05; // trim above bbox top to avoid chin/face (gentle)
  const BOTTOM_PAD_PX = 60;   // fixed extra space below lowest pixel

  // Load BodyPix
  let net;
  try {
    net = await bodyPix.load({
      architecture: 'MobileNetV1',
      outputStride: 16,
      multiplier: 0.75,
      quantBytes: 2
    });
  } catch (e) {
    showErr('Failed to load BodyPix model. Check your internet connection and refresh the page.');
    console.error(e);
    return;
  }

  function loadImage(file){
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
      img.onerror = reject;
      img.src = url;
    });
  }

  function bboxFromMaskAlpha(rgba, w, h){
    let top=h, left=w, right=0, bottom=0, found=false;
    for (let y=0, i=0; y<h; y++){
      for (let x=0; x<w; x++, i+=4){
        if (rgba[i+3] > 0){
          found = true;
          if (x<left) left=x;
          if (x>right) right=x;
          if (y<top) top=y;
          if (y>bottom) bottom=y;
        }
      }
    }
    if (!found) return null;
    return { x:left, y:top, w:(right-left+1), h:(bottom-top+1), bottom };
  }

  // Measure a smart rectangle using overall person segmentation
  async function measureRect(img){
    try{
      // Work at reduced scale for speed; we crop from this scaled canvas
      const maxSide = 1200;
      const scale = Math.min(1, maxSide / Math.max(img.width, img.height));
      const w = Math.round(img.width * scale);
      const h = Math.round(img.height * scale);

      const temp = document.createElement('canvas');
      temp.width = w; temp.height = h;
      const tctx = temp.getContext('2d');
      tctx.drawImage(img, 0, 0, w, h);

      // Person segmentation just to get a mask/bbox
      const seg = await net.segmentPerson(temp, {
        internalResolution: 'high',
        segmentationThreshold: 0.6
      });
      const mask = bodyPix.toMask(seg, {r:255,g:255,b:255,a:255}, {r:0,g:0,b:0,a:0}, false);
      const box = bboxFromMaskAlpha(mask.data, mask.width, mask.height);

      // Fallback if no person found
      if (!box){
        const s = Math.min(w,h);
        const rect = { x: Math.floor((w-s)/2), y: Math.floor((h-s)/2), w:s, h:s };
        return { temp, rect, anchorHeight: s };
      }

      // Expand horizontally to keep arms
      const sidePad = Math.round(box.w * SIDE_PAD_PCT);
      let x  = Math.max(0, box.x - sidePad);
      let rw = Math.min(w - x, box.w + sidePad*2);

      // Gentle head trim to avoid face
      const headTrim = Math.round(box.h * HEAD_TRIM_PCT);
      let y  = Math.max(0, box.y + headTrim);

      // Fixed bottom pad from the lowest foreground pixel
      const yBottomDesired = Math.min(h-1, box.bottom + BOTTOM_PAD_PX);
      let rh = Math.min(h - y, yBottomDesired - y);

      // Clamp to canvas
      if (x + rw > w) rw = w - x;
      if (y + rh > h) rh = h - y;

      // Anchor height (top of bbox before trim -> bottom+pad) for consistent zoom
      const anchorHeight = (yBottomDesired - box.y);

      return { temp, rect: { x, y, w: rw, h: rh }, anchorHeight };
    } catch (e) {
      showErr('Error while analyzing a photo. Try different images or refresh.');
      console.error(e);
      throw e;
    }
  }

  function placeLabel(context, x, y, w, h, label){
    context.save();
    context.fillStyle = '#fff';
    context.fillRect(x, y, w, h + TOP_BANNER);
    context.fillStyle = '#111';
    context.font = 'bold 40px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(label, x + w/2, y + 24);
    context.restore();
  }

  async function build(){
    clearErr();
    const files = [input.front.files[0], input.side.files[0], input.back.files[0]];
    if (!files.every(Boolean)) { showErr('Please select all three photos.'); return; }

    // White background
    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0,out.width,out.height);

    const labels = ['FRONT','SIDE','BACK'];

    // Measure all 3 first so zoom can be normalized by anchor height
    let imgs, measures;
    try{
      imgs = await Promise.all(files.map(loadImage));
      measures = await Promise.all(imgs.map(measureRect));
    } catch { return; }

    // Normalize zoom: use median anchor height (top→bottom+pad)
    const usableH = cellH - 40;
    const targetH = usableH - 24;
    const anchors = measures.map(m => m.anchorHeight).sort((a,b)=>a-b);
    const commonAnchor = anchors[1]; // median

    for (let i=0; i<3; i++){
      const { temp, rect } = measures[i];

      const x = PAD + i * (cellW + GAP);
      const y = PAD;
      placeLabel(ctx, x, y, cellW, cellH, labels[i]);

      const scale = targetH / commonAnchor;
      let drawW = Math.round(rect.w * scale);
      let drawH = Math.round(rect.h * scale);

      const maxW = cellW - 24; // respect side padding
      if (drawW > maxW){
        const s = maxW / drawW;
        drawW = Math.round(drawW * s);
        drawH = Math.round(drawH * s);
      }

      const dx = x + (cellW - drawW)/2;
      const dy = y + 40 + (usableH - drawH)/2;

      ctx.drawImage(temp, rect.x, rect.y, rect.w, rect.h, dx, dy, drawW, drawH);
    }
  }

  buildBtn.addEventListener('click', build);

  dlBtn.addEventListener('click', () => {
    const url = out.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'fit-board-front-side-back.png';
    a.click();
  });
})();
</script>
</body>
</html>
