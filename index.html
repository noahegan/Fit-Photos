<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Free 3‑Photo Fit Board</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
           margin: 24px; background:#f6f7fb; color:#111; }
    h1 { margin: 0 0 8px; }
    .app { max-width: 980px; margin: 0 auto; background:#fff; border-radius: 16px;
           box-shadow: 0 6px 24px rgba(0,0,0,.08); padding: 20px; }
    .grid { display:grid; grid-template-columns: 1fr; gap:16px; }
    @media (min-width:780px){ .grid{ grid-template-columns: repeat(3, 1fr);} }
    .card { background:#fafbff; border:1px solid #e7e9f3; border-radius:12px; padding:14px; }
    label { font-weight: 600; font-size: 14px; display:block; margin-bottom:8px; }
    input[type="file"] { width:100%; padding:10px; border:1px dashed #cdd2e2; border-radius:10px; background:#fff; }
    button { cursor:pointer; border:0; background:#111; color:#fff; padding:12px 16px; border-radius:12px; font-weight:700; }
    button.secondary { background:#fff; color:#111; border:1px solid #d0d5e7; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    canvas { width:100%; max-width:100%; background:#fff; border-radius:12px; border:1px solid #e7e9f3; }
    small.mono { font-family: ui-monospace, Menlo, Consolas, monospace; color:#6b7280; }
  </style>
  <!-- Runs fully in the browser -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0"></script>
</head>
<body>
  <div class="app">
    <h1>Free 3‑Photo Fit Board</h1>
    <p>Upload <b>Front</b>, <b>Side</b>, and <b>Back</b> photos. The tool takes a <b>rectangular crop</b> (not a cut‑out) with consistent framing: includes arms, light head trim, fixed bottom padding, and the same zoom across columns.</p>

    <div class="grid">
      <div class="card"><label>Front</label><input id="front" type="file" accept="image/*" /></div>
      <div class="card"><label>Side</label><input id="side" type="file" accept="image/*" /></div>
      <div class="card"><label>Back</label><input id="back" type="file" accept="image/*" /></div>
    </div>

    <div style="height:12px"></div>
    <div class="row">
      <button id="build">Build Layout</button>
      <button id="download" class="secondary">Download PNG</button>
      <small class="mono">Everything runs on‑device. No uploads.</small>
    </div>

    <div style="height:12px"></div>
    <canvas id="output" width="1500" height="850" aria-label="Final layout canvas"></canvas>
  </div>

<script>
(async function(){
  const input = {
    front: document.getElementById('front'),
    side:  document.getElementById('side'),
    back:  document.getElementById('back')
  };
  const buildBtn = document.getElementById('build');
  const dlBtn = document.getElementById('download');
  const out = document.getElementById('output');
  const ctx = out.getContext('2d');

  // Layout constants
  const PAD = 28, GAP = 16, COLS = 3, TOP_BANNER = 80;
  const cellW = Math.floor((out.width - PAD*2 - GAP*(COLS-1)) / COLS);
  const cellH = out.height - PAD*2 - TOP_BANNER;

  // Framing rules (tweak here)
  const SIDE_PAD_PCT  = 0.12; // keep arms (each side = 12% of bbox width)
  const HEAD_TRIM_PCT = 0.06; // trim above torso top to avoid chin/face
  const BOTTOM_PAD_PX = 50;   // fixed extra space below legs/hem

  // Load BodyPix
  const net = await bodyPix.load({
    architecture: 'MobileNetV1',
    outputStride: 16,
    multiplier: 0.75,
    quantBytes: 2
  });

  function loadImage(file){
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
      img.onerror = reject;
      img.src = url;
    });
  }

  // Measure a smart rectangle using PART segmentation (torso/arms/legs)
  async function measureRect(img){
    // Work at reduced scale for speed; we crop from this scaled canvas
    const maxSide = 1000;
    const scale = Math.min(1, maxSide / Math.max(img.width, img.height));
    const w = Math.round(img.width * scale);
    const h = Math.round(img.height * scale);

    const temp = document.createElement('canvas');
    temp.width = w; temp.height = h;
    const tctx = temp.getContext('2d');
    tctx.drawImage(img, 0, 0, w, h);

    const parts = await net.segmentPersonParts(temp, {
      internalResolution: 'high',
      segmentationThreshold: 0.6
    });

    const names = parts.partNames;
    const data  = parts.data;

    const EXTENTS = new Set([
      'torso','leftUpperArm','rightUpperArm','leftLowerArm','rightLowerArm','leftHand','rightHand',
      'leftUpperLeg','rightUpperLeg','leftLowerLeg','rightLowerLeg','leftFoot','rightFoot'
    ]);
    const TORSO = new Set(['torso']);
    const LEGS  = new Set(['leftUpperLeg','rightUpperLeg','leftLowerLeg','rightLowerLeg','leftFoot','rightFoot']);

    let minX=w, maxX=0, torsoTop=h, legsBottom=0, found=false;

    for (let y=0, i=0; y<h; y++){
      for (let x=0; x<w; x++, i++){
        const name = names[data[i]];
        if (!name) continue;
        if (EXTENTS.has(name)) {
          found = true;
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
        }
        if (TORSO.has(name) && y < torsoTop) torsoTop = y;
        if (LEGS.has(name)  && y > legsBottom) legsBottom = y;
      }
    }

    // Fallback center square if no detection
    if (!found){
      const s = Math.min(w,h);
      return { temp, rect: { x:(w-s)/2, y:(h-s)/2, w:s, h:s }, anchorHeight: s };
    }

    // Apply framing rules
    const sidePad = Math.round((maxX - minX + 1) * SIDE_PAD_PCT);
    const x  = Math.max(0, minX - sidePad);
    const rw = Math.min(w - x, (maxX - minX + 1) + sidePad*2);

    const shoulderToBottom = Math.max(10, legsBottom - torsoTop);
    const headTrim = Math.round(shoulderToBottom * HEAD_TRIM_PCT);
    const yTop = Math.max(0, torsoTop + headTrim);

    const yBottomDesired = Math.min(h-1, legsBottom + BOTTOM_PAD_PX);
    const rh = Math.min(h - yTop, yBottomDesired - yTop);

    const anchorHeight = yBottomDesired - torsoTop; // torso-top -> bottom+pad anchor

    return { temp, rect: { x, y: yTop, w: rw, h: rh }, anchorHeight };
  }

  function placeLabel(context, x, y, w, h, label){
    context.save();
    context.fillStyle = '#fff';
    context.fillRect(x, y, w, h + TOP_BANNER);
    context.fillStyle = '#111';
    context.font = 'bold 40px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(label, x + w/2, y + 24);
    context.restore();
  }

  async function build(){
    const files = [input.front.files[0], input.side.files[0], input.back.files[0]];
    if (!files.every(Boolean)) { alert('Please select all three photos.'); return; }

    // White background
    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0,out.width,out.height);

    const labels = ['FRONT','SIDE','BACK'];

    // Measure all 3 first so zoom can be normalized by anchor height
    const imgs = await Promise.all(files.map(loadImage));
    const measures = await Promise.all(imgs.map(measureRect));

    // Normalize zoom: use median anchor height (torso-top → bottom+pad)
    const usableH = cellH - 40;
    const targetH = usableH - 24;
    const anchors = measures.map(m => m.anchorHeight).sort((a,b)=>a-b);
    const commonAnchor = anchors[1]; // median

    for (let i=0; i<3; i++){
      const { temp, rect } = measures[i];

      const x = PAD + i * (cellW + GAP);
      const y = PAD;
      placeLabel(ctx, x, y, cellW, cellH, labels[i]);

      const scale = targetH / commonAnchor;
      let drawW = Math.round(rect.w * scale);
      let drawH = Math.round(rect.h * scale);

      const maxW = cellW - 24; // respect side padding
      if (drawW > maxW){
        const s = maxW / drawW;
        drawW = Math.round(drawW * s);
        drawH = Math.round(drawH * s);
      }

      const dx = x + (cellW - drawW)/2;
      const dy = y + 40 + (usableH - drawH)/2;

      // Draw rectangular crop from the scaled photo
      ctx.drawImage(temp, rect.x, rect.y, rect.w, rect.h, dx, dy, drawW, drawH);
    }
  }

  buildBtn.addEventListener('click', build);

  dlBtn.addEventListener('click', () => {
    const url = out.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'fit-board-front-side-back.png';
    a.click();
  });
})();
</script>
</body>
</html>
