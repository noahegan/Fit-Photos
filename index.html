<script>
(async function(){
  const fileInputs = {
    front: document.getElementById('front'),
    side:  document.getElementById('side'),
    back:  document.getElementById('back')
  };
  const buildBtn = document.getElementById('build');
  const dlBtn = document.getElementById('download');
  const out = document.getElementById('output');
  const ctx = out.getContext('2d');

  // Layout
  const PAD = 28, GAP = 16, COLS = 3, TOP_BANNER = 80;
  const cellW = Math.floor((out.width - PAD*2 - GAP*(COLS-1)) / COLS);
  const cellH = out.height - PAD*2 - TOP_BANNER;

  // Crop rules (tweak as you like)
  const SIDE_PAD_PCT   = 0.12;  // widen to keep arms (12% of bbox width each side)
  const HEAD_TRIM_PCT  = 0.10;  // remove top 10% of bbox to avoid face
  const BOTTOM_PAD_PX  = 40;    // fixed extra space below lowest pixel

  // Load BodyPix (browser-only)
  const net = await bodyPix.load({
    architecture: 'MobileNetV1', outputStride: 16, multiplier: 0.75, quantBytes: 2
  });

  function loadImage(file){
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
      img.onerror = reject;
      img.src = url;
    });
  }

  function bboxFromMaskAlpha(alphaRGBA, w, h){
    let top=h, left=w, right=0, bottom=0, found=false;
    for (let y=0, i=0; y<h; y++){
      for (let x=0; x<w; x++, i+=4){
        if (alphaRGBA[i+3] > 0){
          found = true;
          if (x<left) left=x;
          if (x>right) right=x;
          if (y<top) top=y;
          if (y>bottom) bottom=y;
        }
      }
    }
    if (!found) return null;
    return { x:left, y:top, w:(right-left+1), h:(bottom-top+1), bottom };
  }

  async function measureRect(img){
    // Work on a scaled copy for speed; weâ€™ll crop from this same scaled canvas
    const maxSide = 1000;
    const scale = Math.min(1, maxSide / Math.max(img.width, img.height));
    const w = Math.round(img.width * scale);
    const h = Math.round(img.height * scale);

    const temp = document.createElement('canvas');
    temp.width = w; temp.height = h;
    const tctx = temp.getContext('2d');
    tctx.drawImage(img, 0, 0, w, h);

    // Person segmentation to get a mask for bbox only
    const seg = await net.segmentPerson(temp, { internalResolution: 'high', segmentationThreshold: 0.6 });
    const fg = { r: 255, g: 255, b: 255, a: 255 }, bg = { r:0, g:0, b:0, a:0 };
    const mask = bodyPix.toMask(seg, fg, bg, false); // filled mask
    const box = bboxFromMaskAlpha(mask.data, mask.width, mask.height);

    // If segmentation fails, fallback to center crop
    let rect;
    if (!box){
      const s = Math.min(w,h);
      rect = { x: Math.floor((w-s)/2), y: Math.floor((h-s)/2), w:s, h:s, bottom: Math.floor((h+s)/2) };
    } else {
      // Expand horizontally to keep arms
      const sidePad = Math.round(box.w * SIDE_PAD_PCT);
      let x = Math.max(0, box.x - sidePad);
      let y = box.y;
      let rw = Math.min(w - x, box.w + sidePad*2);
      let rh = box.h;

      // Trim head (hide face)
      const headTrim = Math.round(rh * HEAD_TRIM_PCT);
      y += headTrim;
      rh -= headTrim;

      // Ensure consistent bottom padding
      const desiredBottom = Math.min(h-1, box.bottom + BOTTOM_PAD_PX);
      rh = Math.min(h - y, desiredBottom - y);

      // Ensure rectangle stays on-canvas
      if (x + rw > w) rw = w - x;
      if (y + rh > h) rh = h - y;

      rect = { x, y, w: rw, h: rh, bottom: desiredBottom };
    }

    return { temp, rect }; // crop from temp using rect
  }

  function placeLabel(context, x, y, w, h, label){
    context.save();
    context.fillStyle = '#fff';
    context.fillRect(x, y, w, h + TOP_BANNER);
    context.fillStyle = '#111';
    context.font = 'bold 40px Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(label, x + w/2, y + 24);
    context.restore();
  }

  async function build(){
    const files = [fileInputs.front.files[0], fileInputs.side.files[0], fileInputs.back.files[0]];
    if (!files.every(Boolean)) { alert('Please select all three photos.'); return; }

    // Clear board
    ctx.clearRect(0,0,out.width,out.height);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0,out.width,out.height);

    const labels = ['FRONT','SIDE','BACK'];

    // Load + measure all 3 first so we can normalize scale
    const imgs = await Promise.all(files.map(loadImage));
    const measures = await Promise.all(imgs.map(measureRect));

    // Normalize zoom by the rectangle height (median to avoid outliers)
    const usableH = cellH - 40;
    const targetH = usableH - 24;
    const rectHeights = measures.map(m => m.rect.h).sort((a,b)=>a-b);
    const commonH = rectHeights[1]; // median

    for (let i=0; i<3; i++){
      const { temp, rect } = measures[i];

      const x = PAD + i * (cellW + GAP);
      const y = PAD;
      placeLabel(ctx, x, y, cellW, cellH, labels[i]);

      const scale = targetH / commonH;
      let drawW = Math.round(rect.w * scale);
      let drawH = Math.round(rect.h * scale);

      // Fit within width if needed
      const maxW = cellW - 24;
      if (drawW > maxW){
        const s = maxW / drawW;
        drawW = Math.round(drawW * s);
        drawH = Math.round(drawH * s);
      }

      const dx = x + (cellW - drawW)/2;
      const dy = y + 40 + (usableH - drawH)/2;

      // Draw the rectangular crop directly from the scaled photo
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.10)';
      ctx.shadowBlur = 10; ctx.shadowOffsetY = 5;
      ctx.drawImage(temp, rect.x, rect.y, rect.w, rect.h, dx, dy, drawW, drawH);
      ctx.restore();
    }
  }

  buildBtn.addEventListener('click', () => build());
  dlBtn.addEventListener('click', () => {
    const url = out.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'fit-board-front-side-back.png';
    a.click();
  });
})();
</script>
