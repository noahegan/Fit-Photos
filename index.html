<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Free 3‑Photo Fit Board (Front / Side / Back)</title>
  <style>
    :root { --pad:28px; --gap:16px; --banner:80px; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
           margin: 24px; background:#f6f7fb; color:#111; }
    h1 { margin: 0 0 8px; }
    .app { max-width: 980px; margin: 0 auto; background:#fff; border-radius: 16px;
           box-shadow: 0 6px 24px rgba(0,0,0,.08); padding: 20px; }
    .grid { display:grid; grid-template-columns: 1fr; gap:16px; }
    @media(min-width:780px){ .grid{ grid-template-columns: repeat(3, 1fr);} }
    .card { background:#fafbff; border:1px solid #e7e9f3; border-radius:12px; padding:14px; }
    label { font-weight: 600; font-size: 14px; display:block; margin-bottom:8px; }
    input[type="file"] { width:100%; padding:10px; border:1px dashed #cdd2e2; border-radius:10px; background:#fff; }
    button { cursor:pointer; border:0; background:#111; color:#fff; padding:12px 16px; border-radius:12px; font-weight:700; }
    button.secondary { background:#fff; color:#111; border:1px solid #d0d5e7; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    canvas { width:100%; max-width:100%; background:#fff; border-radius:12px; border:1px solid #e7e9f3; }
    small.mono { font-family: ui-monospace, Menlo, Consolas, monospace; color:#6b7280; }
  </style>
  <!-- TensorFlow.js + BodyPix (runs fully in the browser) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0"></script>
</head>
<body>
  <div class="app">
    <h1>Free 3‑Photo Fit Board</h1>
    <p>Upload <b>Front</b>, <b>Side</b>, and <b>Back</b> photos. This page will <b>auto‑segment</b> the person, <b>crop</b> to the silhouette, and <b>compose</b> a board labeled FRONT / SIDE / BACK — all locally in your browser.</p>

    <div class="grid">
      <div class="card"><label>Front</label><input id="front" type="file" accept="image/*" /></div>
      <div class="card"><label>Side</label><input id="side" type="file" accept="image/*" /></div>
      <div class="card"><label>Back</label><input id="back" type="file" accept="image/*" /></div>
    </div>

    <div style="height:12px"></div>
    <div class="row">
      <button id="build">Build Layout</button>
      <button id="download" class="secondary">Download PNG</button>
      <small class="mono">Everything runs on‑device. No uploads.</small>
    </div>

    <div style="height:12px"></div>
    <canvas id="output" width="1500" height="850" aria-label="Final layout canvas"></canvas>

    <p><small class="mono">Tip: for best results, use full‑body photos against a clean background. If segmentation fails, the tool falls back to a smart centered crop.</small></p>
  </div>

<script>
(async function(){
  const fileInputs = {
    front: document.getElementById('front'),
    side:  document.getElementById('side'),
    back:  document.getElementById('back')
  };

  const buildBtn = document.getElementById('build');
  const dlBtn = document.getElementById('download');
  const out = document.getElementById('output');
  const ctx = out.getContext('2d');

  // Board layout constants
  const PAD = 28, GAP = 16;
  const COLS = 3;
  const TOP_BANNER = 80; // space for the FRONT/SIDE/BACK words
  const cellW = Math.floor((out.width - PAD*2 - GAP*(COLS-1)) / COLS);
  const cellH = out.height - PAD*2 - TOP_BANNER;

  // Load BodyPix
  const net = await bodyPix.load({
    architecture: 'MobileNetV1',
    outputStride: 16,
    multiplier: 0.75,
    quantBytes: 2
  });

  function loadImage(file){
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
      img.onerror = reject;
      img.src = url;
    });
  }

  function getBoundingBoxFromMask(maskRGBA, width, height){
    // maskRGBA = Uint8ClampedArray of RGBA; keep pixels with alpha > 0
    let top = height, left = width, right = 0, bottom = 0;
    let found = false;

    for(let y=0, i=0; y<height; y++){
      for(let x=0; x<width; x++, i+=4){
        const a = maskRGBA[i+3];
        if (a > 0){
          found = true;
          if (x < left) left = x;
          if (x > right) right = x;
          if (y < top) top = y;
          if (y > bottom) bottom = y;
        }
      }
    }
    if (!found) return null;

    // add breathing room
    const margin = 18;
    left = Math.max(0, left - margin);
    top = Math.max(0, top - margin);
    right = Math.min(width-1, right + margin);
    bottom = Math.min(height-1, bottom + margin);

    return { x:left, y:top, w:(right-left+1), h:(bottom-top+1) };
  }

  async function segmentAndCrop(img){
    // Downscale for speed
    const maxSide = 900;
    const scale = Math.min(1, maxSide / Math.max(img.width, img.height));
    const w = Math.round(img.width * scale);
    const h = Math.round(img.height * scale);

    const temp = document.createElement('canvas');
    temp.width = w; temp.height = h;
    const tctx = temp.getContext('2d');
    tctx.drawImage(img, 0, 0, w, h);

    // Person segmentation (slightly lower threshold to keep thin limbs)
    const segmentation = await net.segmentPerson(temp, {
      internalResolution: 'high',
      segmentationThreshold: 0.6
    });

    // FILLED mask (the previous issue was contour-only)
    const fg = { r: 255, g: 255, b: 255, a: 255 }; // opaque foreground
    const bg = { r: 0, g: 0, b: 0, a: 0 };         // transparent background
    const mask = bodyPix.toMask(segmentation, fg, bg, /*drawContour=*/false);

    // Measure subject bounds
    const box = getBoundingBoxFromMask(mask.data, mask.width, mask.height);

    // Fallback smart center crop if mask failed
    const fallback = !box
      ? { x: Math.max(0, (w - Math.min(w,h))/2), y: Math.max(0, (h - Math.min(w,h))/2), w: Math.min(w,h), h: Math.min(w,h) }
      : box;

    // Create a masked, trimmed canvas
    const outC = document.createElement('canvas');
    outC.width = fallback.w; outC.height = fallback.h;
    const octx = outC.getContext('2d');

    // Put mask RGBA into a canvas
    const maskCanvas = document.createElement('canvas');
    maskCanvas.width = mask.width; maskCanvas.height = mask.height;
    const mctx = maskCanvas.getContext('2d');
    const mimg = new ImageData(mask.data, mask.width, mask.height);
    mctx.putImageData(mimg, 0, 0);

    // Draw trimmed masked region
    octx.save();
    octx.drawImage(maskCanvas, fallback.x, fallback.y, fallback.w, fallback.h, 0, 0, fallback.w, fallback.h);
    octx.globalCompositeOperation = 'source-in';
    octx.drawImage(temp,       fallback.x, fallback.y, fallback.w, fallback.h, 0, 0, fallback.w, fallback.h);
    octx.restore();

    // Return both the trimmed person and their raw height for normalization
    return { canvas: outC, personHeight: fallback.h };
  }

  function placeLabeled(context, x, y, w, h, label){
    context.save();
    context.fillStyle = '#fff';
    context.fillRect(x, y, w, h + TOP_BANNER);

    // Label
    context.fillStyle = '#111';
    context.font = 'bold 40px Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(label, x + w/2, y + 24);
    context.restore();
  }

  async function build(){
    const files = [fileInputs.front.files[0], fileInputs.side.files[0], fileInputs.back.files[0]];
    if (!files.every(Boolean)) {
      alert('Please select all three photos (Front, Side, Back).');
      return;
    }

    // Clear board
    ctx.clearRect(0,0,out.width,out.height);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,out.width,out.height);

    const labels = ['FRONT', 'SIDE', 'BACK'];

    // Segment all three first so we can normalize scale by person height
    const loaded = await Promise.all(files.map(loadImage));
    const trimmed = await Promise.all(loaded.map(segmentAndCrop));

    // Compute a common target "person height" so the three columns look consistent
    const usableH = cellH - 40;      // below the label
    const targetH = usableH - 24;    // bottom padding
    const medianHeight = trimmed.map(t => t.personHeight).sort((a,b)=>a-b)[1]; // simple median of 3

    for (let i=0; i<3; i++){
      const { canvas: personCanvas, personHeight } = trimmed[i];

      // Column rect
      const x = PAD + i * (cellW + GAP);
      const y = PAD;
      placeLabeled(ctx, x, y, cellW, cellH, labels[i]);

      // Normalize scale so heights match across columns (but still respect cell bounds)
      const normScale = targetH / medianHeight;
      let drawW = Math.round(personCanvas.width  * normScale);
      let drawH = Math.round(personCanvas.height * normScale);

      // Ensure we still fit in width
      const maxW = cellW - 24; // side padding
      if (drawW > maxW){
        const s = maxW / drawW;
        drawW = Math.round(drawW * s);
        drawH = Math.round(drawH * s);
      }

      const dx = x + (cellW - drawW)/2;
      const dy = y + 40 + (usableH - drawH)/2;

      ctx.save();
      // Soft shadow for legibility
      ctx.shadowColor = 'rgba(0,0,0,0.14)';
      ctx.shadowBlur = 14; ctx.shadowOffsetY = 6;
      ctx.drawImage(personCanvas, dx, dy, drawW, drawH);
      ctx.restore();
    }
  }

  buildBtn.addEventListener('click', () => build());

  dlBtn.addEventListener('click', () => {
    const url = out.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'fit-board-front-side-back.png';
    a.click();
  });
})();
</script>
</body>
</html>
